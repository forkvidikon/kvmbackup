
##################### Переменные ##########################

# Данные переменные необходимы для корректной работы скрипта.
# ВАЖНО! Переменную 'echofile' следует использовать только для
# для записи в нее потока STDERR и последующей передачи ее в обработчик ошибок.
# Не рекомендуется использовать в любых других случаях, так как высока вероятность потери данных

echofile=$(tempfile /tmp/backup.XXXXXX)
TIME=$(date +%Y-%m-%d)
MOMENT=$(date  +%Y-%m-%d\ %H:%M:%S)



################################## Обработка конфигурационных файлов .yml ##################################

# Функция вызывается с указанием аргумента (файлом конфигурации),
# разбирает файл на переменные и заполняет их значениями

function parse_yaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'

 }

################################## Обработка конфигурационных файлов .yml ##################################

 ################################## Функция проверки конфигурации ##################################

# Функция служит для проверки конфигурационного файла на ошибки,
# такие как: 
#   * в качестве аргумента передан не файл 
#   * файл не содержит имени виртуальной машины
#   * указанная виртуальная машина не существует
#   * неверно указан путь

function check_configuration {
    # Проверяем, существует ли файл и не пустой ли он
    if [[ -f $1 ]] && [[ -n $1 ]]
        then
            # Если файл не пустой, то попытаться распарсить его и вытащить переменные
           eval $(parse_yaml $1)   
            # Проверяем, не пустое ли имя виртуальной машины. (Проверяем существование обязательной переменной в файле)
            if [[ -z $vmachine_name ]]
                then 
                    # Если переменная пустая (отсутствует в конфиге или пустая) то обрабатываем ошибку. exit code 1
                    error_handler 1 "Проверьте указанные данные. Не указано имя виртуальной машины" 
                # Проверяем, существует ли указанная виртуальная машина
                elif [[ -z $(virsh list --all | grep $vmachine_name) ]]
                    then
                        error_handler 1 "Указанная виртуальная машина не существует. Проверьте введенные данные"                                     
            fi
        else
            # Если нет аргументов или их больше одного или аргумент не является файлом - обрабатываем ошибку. exit code 1
            error_handler 1 "Скрипт необходимо запускать с валидным файлом конфигурации, указанном в качестве аргумента"
    fi

    # Проверка директории для логов

    if [[ $notification = "yes" ]] && [[ -d $notification_patch ]]
        then
            error_handler 0 0 "Директория для логов найдена" 
        elif [[ $notification != "yes" ]]
            then 
                error_handler 0 0 "Логирование не требуется"
            else
                error_handler 1 "Не удалось найти директорию для логов. Проверьте путь" "Проверка директории для логов"
    fi
}
################################## Функция проверки конфигурации ##################################

################################ Обработка ошибок  ###################################

# Функция используется для обработки ошибок (error code) 
# и вывода на экран или логфайл информации о работе скрипта
# Функция принимает и обрабатывает 3 параметра
#   1. Код ошибки. Любой не нулевой код приведет к завершению работы скрипта. Передается либо как число (если нужно обработать ошибку
#       но программа не выполнялась), либо как $? (переменная содержит код выхода последней выполненной программы)
#   2. Текст ошибки. В качестве аргумента может идти текст или файл (текст из файла прочитается на экран или в логфайл).
#       Текст должен содержать описание ошибки или вывод STDERR последней выполенной программы. (Bash не дает перенаправить вывод в переменную
#       поэтому необходимо перенапавлять вывод STDERR в файл, который передается в качестве аргумента)
#   3. Наименования выполняемого действия для более простого поиска ошибок. Каждая функция обязана передавать этот параметр


function error_handler {
    if [[ $1 -ne 0 ]]
        then
            if [[ -f $2 ]]
                then
                    echo -e "[FAIL] Произошла ошибка в действии ($3). Текст ошибки:\n $(cat $2)"
                        if [[ $notification = "yes" ]]
                            then 
                                echo -e "[FAIL] Произошла ошибка в действии ($3). Текст ошибки:\n $(cat $2) $MOMENT" >> $notification_patch/$TIME-$notification_name_logfile
                        fi
                    exit 1
                else
                    echo -e "[FAIL] Произошла ошибка в действии ($3). Текст ошибки:\n $2"
                        if [[ $notification = "yes" ]]
                            then 
                                echo -e "[FAIL] Произошла ошибка в действии ($3). Текст ошибки:\n $2 $MOMENT" >> $notification_patch/$TIME-$notification_name_logfile
                        fi
                    exit 1      
            fi
        else 
            echo -e "[OK] $3 "
            if [[ $notification = "yes" ]]
                then 
                    echo -e "[OK] $3 "  >> $notification_patch/$TIME-$notification_name_logfile
            fi
            
    fi
}

################################ Конец функции  ###################################